# Inspired by:
# https://github.com/nperez0111/bookhive/blob/main/.github/workflows/docker-build.yml

name: Docker Build and Push

# This workflow uses workflow_run triggers to run after CI and BlockNote validation complete.
# 
# IMPORTANT: GitHub triggers workflow_run once per workflow completion, not after all workflows complete.
# This means if "CI" completes successfully, this workflow triggers immediately - it does NOT wait for
# "Validate BlockNote Snapshots" to complete.
#
# To handle this robustly, we:
# 1. Trigger on completion of either workflow
# 2. Check that the triggering workflow succeeded
# 3. Use the GitHub API to verify that BOTH required workflows have completed successfully
#    for the same commit before proceeding with the Docker build
#
# This ensures we only build/push Docker images when all checks pass.
on:
  workflow_run:
    workflows: ["CI", "Validate BlockNote Snapshots"]
    types:
      - completed

permissions:
  contents: read
  packages: write
  id-token: write
  attestations: write

jobs:
  # First job: Check if all required workflows have succeeded
  check-prerequisites:
    runs-on: ubuntu-latest
    outputs:
      all-success: ${{ steps.check.outputs.all-success }}
    steps:
      - name: Check if triggering workflow succeeded
        if: github.event.workflow_run.conclusion != 'success'
        run: |
          echo "Triggering workflow '${{ github.event.workflow_run.name }}' did not succeed (conclusion: ${{ github.event.workflow_run.conclusion }})"
          exit 1

      - name: Check all required workflows
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const requiredWorkflows = ['CI', 'Validate BlockNote Snapshots'];
            const ref = context.payload.workflow_run.head_sha;
            
            console.log(`Checking workflows for commit: ${ref}`);
            
            // Get all workflow runs for this commit
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: ref,
              per_page: 100
            });
            
            console.log(`Found ${runs.workflow_runs.length} workflow runs for this commit`);
            
            // Check each required workflow
            const results = {};
            for (const workflowName of requiredWorkflows) {
              const workflowRuns = runs.workflow_runs.filter(run => run.name === workflowName);
              
              if (workflowRuns.length === 0) {
                console.log(`❌ Workflow '${workflowName}' has not run yet`);
                results[workflowName] = 'not_found';
                continue;
              }
              
              // Get the most recent run
              const latestRun = workflowRuns.sort((a, b) => 
                new Date(b.created_at) - new Date(a.created_at)
              )[0];
              
              console.log(`Workflow '${workflowName}': status=${latestRun.status}, conclusion=${latestRun.conclusion}`);
              
              if (latestRun.status !== 'completed') {
                console.log(`⏳ Workflow '${workflowName}' is still running`);
                results[workflowName] = 'running';
              } else if (latestRun.conclusion !== 'success') {
                console.log(`❌ Workflow '${workflowName}' did not succeed (${latestRun.conclusion})`);
                results[workflowName] = latestRun.conclusion;
              } else {
                console.log(`✅ Workflow '${workflowName}' succeeded`);
                results[workflowName] = 'success';
              }
            }
            
            // Check if all workflows succeeded
            const allSuccess = requiredWorkflows.every(name => results[name] === 'success');
            
            console.log(`All workflows succeeded: ${allSuccess}`);
            core.setOutput('all-success', allSuccess.toString());
            
            if (!allSuccess) {
              console.log('Not all required workflows have succeeded yet. Skipping Docker build.');
            }

  docker:
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.all-success == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: "v2.4.0"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch,filter=branch=main,format=latest
            type=ref,event=tag

      - name: Build (always) and push (only on tags)
        uses: docker/build-push-action@v6
        id: build-and-push
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: ${{ startsWith(github.ref, 'refs/tags/') }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sign the images with GitHub OIDC Token
        if: startsWith(github.ref, 'refs/tags/')
        env:
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail

          images=""
          for tag in $TAGS; do
            images+="${tag}@${DIGEST} "
          done

          echo "Signing these images: $images"
          cosign sign --yes $images
